/*Правительство Берляндии решило улучшать отношения с соседними странами.
В первую очередь было решено построить новые дороги так чтобы из всех городов Берляндии и соседних стран
можно было добраться до всех остальных. Всего в Берляндии и соседних странах n городов и ровно n - 1 двусторонних дорог.
Из-за недавнего финансового кризиса правительство Берляндии сильно стеснено в средствах, поэтому чтобы построить
новую дорогу оно вынуждено закрывать какую-то из существующих. Каждый день можно закрыть одну существующую дорогу
и сразу же построить новую. Ваша задача — определить, сколько дней потребуется для перестройки дороги так, чтобы из любого города можно было добраться до любого другого, а так же составить план закрытия старых и постройки новых дорог.
Дано число городов в Берляндии и соседних странах, список дорог, которые соединяют города. 
Между каждой парой городов не может быть больше одной дороги, никакая дорога
не соединяет город сам с собой. Вывести наименьшее число дней , которое потребуется,
чтобы перестроить дороги так, чтобы из любого города можно было добраться до любого другого. */

/* На банкет были приглашены N Очень Важных Персон (ОВП). Были поставлены 2 стола. Столы достаточно большие, чтобы все посетители банкета могли сесть за любой из них. Проблема заключается в том, что некоторые ОВП не ладят друг с другом и не могут сидеть за одним столом. Вас попросили определить, возможно ли всех ОВП рассадить за двумя столами.*/


#include <iostream>
#include <vector>

using namespace std;

int n;
vector <vector<int> > g(1000);
vector < vector <int > > w;
vector <int> used(1000);
vector<int> comp;
vector<int> p;
vector <pair < int, int > > qwe;

void dfs(int v, int p = -1) {
    used[v] = 1;
    comp.push_back(v);
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to == p)
            continue;
        if (!used[to])
            dfs(to, v);
        else if (v < g[v][i])
            qwe.push_back(make_pair(v + 1, g[v][i] + 1));


    }
}

void find_comps() {
    vector<int> ans;
    p.assign(n, -1);
    for (int i = 0; i < n; ++i)
        used[i] = 0;
    for (int i = 0; i < n; ++i)
        if (!used[i]) {
            comp.clear();
            dfs(i);

            for (size_t j = 0; j < comp.size(); ++j)
            {
                ans.push_back(comp[j]);
            }
            w.push_back(ans);
            ans.clear();




        }

}

int main() {
    vector <pair <int, int> > otv;
    cin >> n;
    int x, y;
    for (int i = 0; i < n - 1; i++) {
        cin >> x;
        cin >> y;
        g[x - 1].push_back(y - 1);
        g[y - 1].push_back(x - 1);
    }
    find_comps();

    cout << w.size() - 1 << endl;
    if (w.size() > 1) {
        for (size_t i = 0; i < w.size() - 1; i++) {
            otv.push_back(make_pair(w[i][0] + 1, w[i + 1][0] + 1));
        }
    }

    for (size_t i = 0; i < otv.size(); i++) {
        cout << qwe[i].first << " " << qwe[i].second << " ";
        cout << otv[i].first << " " << otv[i].second;
        cout << endl;
    }


    return 0;
}