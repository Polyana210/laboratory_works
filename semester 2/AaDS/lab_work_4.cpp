/*10. Дан ломаная, состоящая из N вершин. Для каждой вершины ломаной задаётся некое целое число, 
а для каждого отрезка — операция (сложение или умножение). Количество вершин ломаной последовательно уменьшается по следующему правилу: 
выбирается некоторый отрезок и к числам, приписанных вершинам, которые соединены этим отрезком, применяется операция,
заданная для выбранного отрезка; отрезок и его концы удаляются, а вместо них добавляется новая вершина, для которой задаётся число-результат
выполненной операции. Процесс продолжается до тех пор, пока не останется только одна вершина. 
Для заданной ломанной найти такую последовательность отрезков, при которой число, полученное в последней вершине, будет максимальным. */

#include <iostream>
using namespace std;

int max(int a, int b) {
	if (a > b) return a;
	else return b;
}

int f(int n, int* A) {
	if (n == 1)return A[0];
	else return max(f(n - 1, A) + A[n-1], f(n - 1, A) * A[n-1]);
}

void way(int Num, int* Number, int* Rez) {
	cout << " (";
	for (int i = 0; i < Num - 1; i++) {
		cout << Number[i];
		if (Rez[i] + Number[i + 1] == Rez[i + 1]) cout << ")- + -(";
		else cout << ")- * -(";
	}
	cout << Number[Num - 1]<< ") "<< endl;
	delete[] Rez;
}


int main() {
	try {
		setlocale(LC_ALL, "rus");
		string num;

		cout << "Введите количество вершин ломаной N (натуральное число от 1 до 100):   ";
		cin >> num;
		int Num = atof(num.c_str());
		if (Num <=0 || Num > 100)  throw "не НАТУРАЛЬНОЕ ЧИСЛО ОТ 1 ДО 100 "; 

		int* Number = new int[Num];
		string bb;
		for (int i = 0; i < Num; i++) {
			cout << "Введите целое число от -100 до 100 для " << i + 1 << " вершины ";
			cin >> bb;
			Number[i]= atof(bb.c_str());
			if (Number[i] < -100 || Number[i] > 100)  throw "не ЦЕЛОЕ ЧИСЛО ОТ -100 ДО 100 ";
		}

		int* Rez = new int[Num];

		for (int i = 0; i < Num; i++) {
			Rez[i] = f(i + 1, Number);
		}
		cout << " Максимальный результат в последней вершине при заданной последовательности: " << Rez[Num - 1] << endl << endl;
		cout << " Последовательность отрезков, при которой число, полученное в последней вершине, будет максимальным:" << endl;
		way(Num, Number, Rez);

		delete[] Number;
	}
	catch (const char* exception){
		cerr << "ОШИБКА: " << exception << '\n';
		exit(-1);
	}
	return 0;
}